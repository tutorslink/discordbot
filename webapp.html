<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recordings Webapp</title>
    <link rel="stylesheet" href="/styles.css">
</head>
    <body>
    <!-- Authentication Page -->
    <div id="auth-page" class="auth-container">
        <div class="auth-card">
            <h1>Authentication Required</h1>
            <p>Please enter your authentication code to access recordings.</p>
            <div id="auth-error" class="error-message hidden"></div>
            <form id="auth-form">
                <div class="form-group">
                    <label for="auth-token">Authentication Code</label>
                    <input type="text" id="auth-token" placeholder="Enter authentication code" required autofocus>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Authenticate</button>
            </form>
            <div style="margin-top: 12px; text-align: center;">
                <button id="discord-auth-btn" class="btn btn-secondary" style="width: 100%;">Continue with Discord</button>
            </div>
        </div>
    </div>

    <!-- Recordings List Page -->
    <div id="list-page" class="container hidden">
        <div class="header">
            <h1>Recordings</h1>
            <button class="btn btn-secondary" onclick="logout()">Logout</button>
        </div>
        <div id="recordings-container">
            <div class="spinner"></div>
        </div>
    </div>

    <!-- Recording Detail Page -->
    <div id="detail-page" class="container hidden">
        <div class="header">
            <button class="btn btn-secondary" onclick="showRecordingsList()">← Back to Recordings</button>
        </div>
        <div id="recording-detail-container">
            <div class="spinner"></div>
        </div>
    </div>

    <script type="module">
        // webapp.js - Modular webapp functionality
        
        // State management
        const state = {
            authToken: null,
            currentPage: 'auth',
            currentRecordingId: null
        };

        // Check for token in URL
        const urlParams = new URLSearchParams(window.location.search);
        const urlToken = urlParams.get('token');
        if (urlToken) {
            document.getElementById('auth-token').value = urlToken;
            authenticate(urlToken);
        }

        // Check for recording ID in URL
        const pathParts = window.location.pathname.split('/');
        if (pathParts[1] === 'recording' && pathParts[2]) {
            state.currentRecordingId = pathParts[2];
        }

        // Authentication
        async function authenticate(token) {
            try {
                const response = await fetch('/api/auth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token })
                });

                if (response.ok) {
                    state.authToken = token;
                    if (state.currentRecordingId) {
                        showRecordingDetail(state.currentRecordingId);
                    } else {
                        showRecordingsList();
                    }
                } else {
                    const error = await response.json();
                    showError(error.error || 'Invalid authentication code');
                }
            } catch (error) {
                showError('Failed to authenticate. Please check your connection.');
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('auth-error');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
        }

        // Auth form handler
        document.getElementById('auth-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const token = document.getElementById('auth-token').value.trim();
            if (token) {
                authenticate(token);
            }
        });

        // Discord auth button handler
        document.getElementById('discord-auth-btn').addEventListener('click', async () => {
            try {
                const response = await fetch('/api/discord-auth-url');
                if (response.ok) {
                    const { url } = await response.json();
                    window.location.href = url;
                } else {
                    showError('Discord authentication is not configured.');
                }
            } catch (error) {
                showError('Failed to initiate Discord authentication.');
            }
        });

        // Page navigation
        function showPage(page) {
            document.getElementById('auth-page').classList.add('hidden');
            document.getElementById('list-page').classList.add('hidden');
            document.getElementById('detail-page').classList.add('hidden');
            
            document.getElementById(page + '-page').classList.remove('hidden');
            state.currentPage = page;
        }

        function showRecordingsList() {
            showPage('list');
            loadRecordings();
            // Update URL
            window.history.pushState({}, '', '/');
        }

        async function loadRecordings() {
            const container = document.getElementById('recordings-container');
            container.innerHTML = '<div class="spinner"></div>';

            try {
                const response = await fetch('/api/recordings', {
                    headers: { 'Authorization': `Bearer ${state.authToken}` }
                });

                if (response.status === 401) {
                    logout();
                    return;
                }

                const data = await response.json();
                const recordings = data.recordings || [];

                if (recordings.length === 0) {
                    container.innerHTML = '<div class="empty-state">No recordings found.</div>';
                    return;
                }

                container.innerHTML = '<div class="recordings-grid"></div>';
                const grid = container.querySelector('.recordings-grid');

                recordings.forEach(recording => {
                    const card = document.createElement('div');
                    card.className = 'recording-card';
                    card.onclick = () => showRecordingDetail(recording.recordingId);
                    
                    const date = new Date(recording.createdAt);
                    card.innerHTML = `
                        <h3>${escapeHtml(recording.title)}</h3>
                        <div class="meta">
                            Student: <span id="student-${recording.studentId}">Loading...</span><br>
                            Tutor: ${recording.tutorId ? `<span id="tutor-${recording.tutorId}">Loading...</span>` : 'N/A'}<br>
                            Participants: ${recording.userIds?.length || 0}
                        </div>
                        <div class="date">${date.toLocaleString()}</div>
                    `;
                    
                    grid.appendChild(card);
                    
                    // Try to fetch user info (optional, may fail if Discord API not available)
                    fetchUserInfo(recording.studentId, `student-${recording.studentId}`);
                    if (recording.tutorId) {
                        fetchUserInfo(recording.tutorId, `tutor-${recording.tutorId}`);
                    }
                });
            } catch (error) {
                container.innerHTML = `<div class="error-message">Failed to load recordings: ${error.message}</div>`;
            }
        }

        async function fetchUserInfo(userId, elementId) {
            // This is a placeholder - in a real implementation, you'd need a backend endpoint
            // to fetch Discord user info, or just display the ID
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = `User ${userId.substring(0, 8)}...`;
            }
        }

        function showRecordingDetail(recordingId) {
            state.currentRecordingId = recordingId;
            showPage('detail');
            loadRecordingDetail(recordingId);
            // Update URL
            window.history.pushState({}, '', `/recording/${recordingId}`);
        }

        async function loadRecordingDetail(recordingId) {
            const container = document.getElementById('recording-detail-container');
            container.innerHTML = '<div class="spinner"></div>';

            try {
                const response = await fetch(`/api/recordings/${recordingId}?token=${encodeURIComponent(state.authToken)}`);
                
                if (response.status === 401) {
                    logout();
                    return;
                }

                if (response.status === 404) {
                    container.innerHTML = '<div class="error-message">Recording not found.</div>';
                    return;
                }

                const recording = await response.json();
                renderRecordingDetail(recording);
            } catch (error) {
                container.innerHTML = `<div class="error-message">Failed to load recording: ${error.message}</div>`;
            }
        }

        function renderRecordingDetail(recording) {
            const container = document.getElementById('recording-detail-container');
            const date = new Date(recording.createdAt);
            
            container.innerHTML = `
                <div class="recording-detail">
                    <h2>${escapeHtml(recording.title)}</h2>
                    <div class="meta-info">
                        <div class="meta-item">
                            <label>Recording ID</label>
                            <div class="value">${recording.recordingId}</div>
                        </div>
                        <div class="meta-item">
                            <label>Student</label>
                            <div class="value" id="detail-student-${recording.studentId}">User ${recording.studentId.substring(0, 8)}...</div>
                        </div>
                        <div class="meta-item">
                            <label>Tutor</label>
                            <div class="value">${recording.tutorId ? `<span id="detail-tutor-${recording.tutorId}">User ${recording.tutorId.substring(0, 8)}...</span>` : 'N/A'}</div>
                        </div>
                        <div class="meta-item">
                            <label>Created</label>
                            <div class="value">${date.toLocaleString()}</div>
                        </div>
                        <div class="meta-item">
                            <label>Participants</label>
                            <div class="value">${recording.userIds?.length || 0}</div>
                        </div>
                    </div>
                </div>

                <div class="download-section">
                    <h3>Download Options</h3>
                    <div class="download-options">
                        <div class="download-option">
                            <h4>Multi-Track Download</h4>
                            <p>Download all tracks separately (one file per participant)</p>
                            <select id="multitrack-format-select">
                                <option value="wav">WAV (.wav)</option>
                                <option value="opus">Opus (.opus)</option>
                            </select>
                            <button class="btn btn-primary" onclick="downloadMultiTrack('${recording.recordingId}')">Download Multi-Track</button>
                        </div>
                        <div class="download-option">
                            <h4>Single-Track Download</h4>
                            <p>Download as a single mixed audio file</p>
                            <select id="format-select">
                                <option value="wav">WAV (.wav)</option>
                                <option value="opus">Opus (.opus)</option>
                            </select>
                            <button class="btn btn-primary" onclick="downloadSingleTrack('${recording.recordingId}')">Download Single-Track</button>
                        </div>
                    </div>
                    <div id="progress-container" class="progress-container">
                        <div class="progress-bar">
                            <div id="progress-fill" class="progress-fill"></div>
                        </div>
                        <div id="progress-text" class="progress-text">0%</div>
                    </div>
                </div>

                <div class="delete-section">
                    <h3>Delete Recording</h3>
                    <p style="color: var(--text-secondary); margin-bottom: var(--spacing-md);">
                        Enter the delete key to permanently delete this recording.
                    </p>
                    <input type="text" id="delete-key-input" placeholder="Enter delete key">
                    <button class="btn btn-danger" onclick="deleteRecording('${recording.recordingId}')">Delete Recording</button>
                </div>
            `;

            // Fetch user info
            fetchUserInfo(recording.studentId, `detail-student-${recording.studentId}`);
            if (recording.tutorId) {
                fetchUserInfo(recording.tutorId, `detail-tutor-${recording.tutorId}`);
            }

            // Store audio files for encoding
            window.currentRecording = recording;
        }

        // Ogg Opus muxer - properly wraps raw Opus packets into Ogg container
        // Based on Ogg Opus specification
        function createOggOpusFile(rawOpusData) {
            try {
                if (!rawOpusData || rawOpusData.byteLength === 0) {
                    throw new Error('Empty audio data');
                }
                
                const data = new Uint8Array(rawOpusData);
                const sampleRate = 48000;
                const channels = 2;
                const serialNumber = 0x12345678;
                
                // Create Opus identification header
                const idHeader = createOpusIdHeader(sampleRate, channels);
                
                // Create Opus comment header (minimal)
                const commentHeader = createOpusCommentHeader();
                
                // Create Ogg pages
                const pages = [];
                
                // Page 0: Identification header
                pages.push(createOggPage(idHeader, 0, 0, 2, serialNumber)); // flags: 2 = beginning of stream
                
                // Page 1: Comment header
                pages.push(createOggPage(commentHeader, 1, 0, 0, serialNumber));
                
                // Page 2+: Audio data
                // Split data into packets (each ~960 bytes is roughly one packet at 20ms)
                // Actually, let's use larger chunks to reduce page overhead
                const packetSize = 3840; // ~80ms at 48kHz
                let pageSequence = 2;
                let granulePos = 0;
                
                for (let i = 0; i < data.length; i += packetSize) {
                    const packet = data.slice(i, Math.min(i + packetSize, data.length));
                    // Approximate samples: each byte represents roughly 1 sample at 48kHz
                    // Actually, Opus is compressed, so we estimate based on typical bitrate
                    const estimatedSamples = Math.floor(packet.length * 20); // Rough estimate
                    granulePos += estimatedSamples;
                    pages.push(createOggPage(packet, pageSequence++, granulePos, 0, serialNumber));
                }
                
                // Mark last page with end of stream flag
                if (pages.length > 2) {
                    const lastPage = pages[pages.length - 1];
                    if (lastPage.length > 5) {
                        lastPage[5] |= 4; // Set end of stream flag
                    }
                }
                
                // Combine all pages
                const totalLength = pages.reduce((sum, p) => sum + p.length, 0);
                const result = new Uint8Array(totalLength);
                let offset = 0;
                for (const page of pages) {
                    if (offset + page.length > result.length) {
                        throw new Error('Page overflow when combining pages');
                    }
                    result.set(page, offset);
                    offset += page.length;
                }
                
                return result.buffer;
            } catch (error) {
                console.error('Error creating Ogg Opus file:', error);
                throw new Error('Failed to create Ogg Opus container: ' + error.message);
            }
        }
        
        function createOpusIdHeader() {
            // OpusHead with correct values per specification
            const header = new Uint8Array(19);
            const view = new DataView(header.buffer);
            
            // Magic "OpusHead"
            header[0] = 0x4F; // 'O'
            header[1] = 0x70; // 'p'
            header[2] = 0x75; // 'u'
            header[3] = 0x73; // 's'
            header[4] = 0x48; // 'H'
            header[5] = 0x65; // 'e'
            header[6] = 0x61; // 'a'
            header[7] = 0x64; // 'd'
            
            header[8] = 0x01; // Version = 1
            header[9] = 0x01; // Channel count = 1 (mono)
            
            // Pre-skip = 312 (2 bytes, little-endian)
            view.setUint16(10, 312, true);
            
            // Original sample rate = 48000 (4 bytes, little-endian)
            view.setUint32(12, 48000, true);
            
            // Output gain = 0 (2 bytes, signed, little-endian)
            view.setInt16(16, 0, true);
            
            // Channel mapping = 0
            header[18] = 0x00;
            
            return header;
        }
        
        function createOpusCommentHeader() {
            // OpusTags with vendor "ISO Recorder", no additional tags
            const vendor = 'ISO Recorder';
            const vendorLength = vendor.length;
            // Structure: 8 bytes "OpusTags" + 4 bytes vendor length + vendor string + 4 bytes comment count
            const header = new Uint8Array(8 + 4 + vendorLength + 4);
            const view = new DataView(header.buffer);
            
            // Magic "OpusTags"
            header[0] = 0x4F; // 'O'
            header[1] = 0x70; // 'p'
            header[2] = 0x75; // 'u'
            header[3] = 0x73; // 's'
            header[4] = 0x54; // 'T'
            header[5] = 0x61; // 'a'
            header[6] = 0x67; // 'g'
            header[7] = 0x73; // 's'
            
            // Vendor length at offset 8 (4 bytes, little-endian)
            view.setUint32(8, vendorLength, true);
            
            // Vendor string at offset 12
            for (let i = 0; i < vendorLength; i++) {
                header[12 + i] = vendor.charCodeAt(i);
            }
            
            // Comment count at offset 12 + vendorLength (4 bytes, little-endian)
            // No additional tags
            view.setUint32(12 + vendorLength, 0, true);
            
            return header;
        }
        
        function createOggPage(packet, sequenceNumber, granulePos, flags, serialNumber) {
            const packetLength = packet.length;
            
            // Handle empty packets
            if (packetLength === 0) {
                const page = new Uint8Array(27 + 1); // Minimum page size
                const view = new DataView(page.buffer);
                
                page[0] = 0x4F; page[1] = 0x67; page[2] = 0x67; page[3] = 0x53;
                page[4] = 0;
                page[5] = flags;
                view.setUint32(6, granulePos & 0xFFFFFFFF, true);
                view.setUint32(10, Math.floor(granulePos / 0x100000000), true);
                view.setUint32(14, serialNumber, true);
                view.setUint32(18, sequenceNumber, true);
                view.setUint32(22, 0, true);
                page[26] = 1; // One segment of size 0
                page[27] = 0; // Segment table entry
                
                // CRC over whole page
                view.setUint32(22, computeOggCRC32(page), true);
                return page;
            }
            
            const segments = Math.ceil(packetLength / 255);
            const segmentTable = new Uint8Array(segments);
            
            let remaining = packetLength;
            for (let i = 0; i < segments; i++) {
                segmentTable[i] = Math.min(255, remaining);
                remaining -= 255;
            }
            
            const headerSize = 27 + segments;
            const pageSize = headerSize + packetLength;
            
            // Ensure minimum page size
            if (pageSize < 28) {
                throw new Error('Page size too small');
            }
            
            const page = new Uint8Array(pageSize);
            const view = new DataView(page.buffer, 0, pageSize);
            
            // OggS
            page[0] = 0x4F; page[1] = 0x67; page[2] = 0x67; page[3] = 0x53;
            page[4] = 0; // Version
            page[5] = flags; // Header type
            
            // Granule position (64-bit, little-endian)
            view.setUint32(6, granulePos & 0xFFFFFFFF, true);
            view.setUint32(10, Math.floor(granulePos / 0x100000000), true);
            
            // Serial number
            view.setUint32(14, serialNumber, true);
            
            // Sequence number
            view.setUint32(18, sequenceNumber, true);
            
            // CRC (will be calculated after page is built)
            view.setUint32(22, 0, true);
            
            // Number of segments
            page[26] = segments;
            
            // Segment table
            if (segments > 0 && 27 + segments <= pageSize) {
                page.set(segmentTable, 27);
            }
            
            // Packet data
            if (27 + segments + packetLength <= pageSize) {
                page.set(packet, 27 + segments);
            } else {
                throw new Error('Packet data exceeds page size');
            }
            
            // Calculate and write CRC32 checksum over entire page
            const crc = computeOggCRC32(page);
            view.setUint32(22, crc, true);
            
            return page;
        }
        
        // Calculate Ogg page CRC32 checksum over the entire page (checksum field zeroed)
        // Ogg uses polynomial 0x04C11DB7 with a non-reflected algorithm:
        // crc = (crc << 8) ^ table[((crc >> 24) ^ byte) & 0xFF]
        function computeOggCRC32(page) {
            const crc32Table = getCRC32Table();
            const tmp = new Uint8Array(page);
            const view = new DataView(tmp.buffer);
            view.setUint32(22, 0, true); // zero checksum before calculation
            let crc = 0 >>> 0;
            for (let i = 0; i < tmp.length; i++) {
                const idx = ((crc >>> 24) ^ tmp[i]) & 0xFF;
                crc = ((crc << 8) ^ crc32Table[idx]) >>> 0;
            }
            return crc >>> 0;
        }
        
        // Generate CRC32 lookup table (polynomial 0x04C11DB7, non-reflected, per Ogg spec)
        function getCRC32Table() {
            if (window._crc32Table) {
                return window._crc32Table;
            }
            
            const polynomial = 0x04C11DB7;
            window._crc32Table = new Array(256);
            
            for (let i = 0; i < 256; i++) {
                let crc = i << 24;
                for (let j = 0; j < 8; j++) {
                    if ((crc & 0x80000000) !== 0) {
                        crc = ((crc << 1) ^ polynomial) >>> 0;
                    } else {
                        crc = (crc << 1) >>> 0;
                    }
                }
                window._crc32Table[i] = crc >>> 0;
            }
            
            return window._crc32Table;
        }
        
        // Parse raw dump file format: [uint16 frameLength][frameData][uint32 timestampLow][uint32 timestampHigh] repeated
        // Reconstruct 64-bit timestamp: timestamp = timestampLow + timestampHigh * 2**32
        function parseRawDump(arrayBuffer) {
            const data = new Uint8Array(arrayBuffer);
            const frames = [];
            let offset = 0;
            
            while (offset < data.length) {
                // Read frame length (2 bytes, little-endian)
                if (offset + 2 > data.length) break;
                const frameLength = new DataView(data.buffer, offset, 2).getUint16(0, true);
                offset += 2;
                
                // Read frame data
                if (offset + frameLength > data.length) {
                    console.warn(`Incomplete frame at offset ${offset}: need ${frameLength} bytes, have ${data.length - offset}`);
                    break;
                }
                const frameData = data.slice(offset, offset + frameLength);
                offset += frameLength;
                
                // Read 64-bit timestamp split into two uint32 values (little-endian)
                if (offset + 8 > data.length) break;
                const timestampLow = new DataView(data.buffer, offset, 4).getUint32(0, true);
                const timestampHigh = new DataView(data.buffer, offset + 4, 4).getUint32(0, true);
                offset += 8;
                
                // Reconstruct 64-bit timestamp
                // Note: JavaScript numbers are safe up to 2^53, but we can handle larger values
                // For very large timestamps, we use multiplication to avoid precision loss
                const timestamp = timestampLow + timestampHigh * 0x100000000;
                
                frames.push({ data: frameData, timestamp });
            }
            
            return frames;
        }
        
        // Decode raw dump file to AudioBuffer (returns only buffer)
        async function decodeRawDumpToAudioBuffer(rawDumpData, audioContext) {
            const { audioBuffer } = await decodeRawDumpWithTiming(rawDumpData, audioContext);
            return audioBuffer;
        }

        // Decode raw dump file and return AudioBuffer plus start timestamp (ms) from first frame
        async function decodeRawDumpWithTiming(rawDumpData, audioContext) {
            // Parse raw dump
            const frames = parseRawDump(rawDumpData);
            if (frames.length === 0) {
                throw new Error('No Opus frames found in raw dump file');
            }

            // Capture earliest timestamp to align tracks
            let minTimestamp = Number.MAX_SAFE_INTEGER;
            for (const f of frames) {
                if (typeof f.timestamp === 'number' && f.timestamp < minTimestamp) {
                    minTimestamp = f.timestamp;
                }
            }

            // Rebuild Ogg/Opus
            const oggOpusData = createOggOpusFromFrames(frames);
            const oggBytes = new Uint8Array(oggOpusData);
            const blob = new Blob([oggBytes], { type: 'audio/ogg; codecs=opus' });
            const arrayBuffer = await blob.arrayBuffer();

            try {
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                return { audioBuffer, startMs: minTimestamp };
            } catch (decodeError) {
                console.error('❌ Opus decode error:', decodeError);
                throw new Error('Failed to decode Opus audio: ' + decodeError.message);
            }
        }
        
        // Parse Opus TOC byte to determine frame duration and count (spec-accurate)
        function parseOpusTOC(tocByte) {
            // TOC layout (RFC 6716):
            // Bits 0-1 : Frame count code (0=1 frame, 1=2 CBR, 2=2 VBR, 3=VBR many)
            // Bits 2-7 : Config (mode/bandwidth/frame size)
            const frameCountCode = tocByte & 0x03;
            const config = tocByte >> 2; // upper 6 bits
            const stereo = false; // Discord sends mono; keep for completeness

            // Guard: valid config range is 0-31 (SILK/hybrid/CELT). If out of range, mark invalid.
            if (config > 31) {
                return { invalid: true, samplesPerPacket: 0, config, frameCountCode, stereo };
            }

            // Frame count
            let frameCount = 1;
            if (frameCountCode === 1 || frameCountCode === 2) {
                frameCount = 2;
            } else if (frameCountCode === 3) {
                // Arbitrary number of frames; Discord typically uses 1
                frameCount = 1;
            }

            // Frame size (samples per frame) per config
            // SILK/hybrid configs (0-15): 10/20/40/60 ms based on (config & 3)
            // CELT-only configs (16+): 2.5/5/10/20 ms using 120 * 2^(config & 3)
            let samplesPerFrame = 0;
            if (config < 16) {
                const silkSamples = [480, 960, 1920, 2880];
                samplesPerFrame = silkSamples[config & 0x03] || 0;
            } else {
                // CELT-only: 2.5ms base (120 samples at 48kHz)
                samplesPerFrame = 120 * Math.pow(2, config & 0x03);
            }

            const durationMs = samplesPerFrame / 48; // 48kHz => 48 samples per ms
            const samplesPerPacket = samplesPerFrame * frameCount;

            return {
                config,
                stereo,
                frameCountCode,
                durationMs,
                frameCount,
                samplesPerFrame,
                samplesPerPacket
            };
        }

        // Check if frame is Opus comfort noise (CNG) - must be skipped
        function isComfortNoiseFrame(frameData) {
            // CNG frames: frameLength <= 3 AND frameData[0] == 0xF8
            return frameData.length <= 3 && frameData[0] === 0xF8;
        }

        // Calculate sample count for a single Opus frame
        // Discord uses fixed-duration Opus frames (typically 20ms at 48kHz = 960 samples).
        // Using a fixed 960 samples per non-CNG packet is robust and avoids under-estimating
        // granule positions, which can cause the end of the audio to be cut off.
        function getSampleCountForFrame(frameData) {
            if (!frameData || frameData.length === 0) return 0;
            if (isComfortNoiseFrame(frameData)) return 0;
            // 20ms * 48kHz
            return 960;
        }

        // Create Ogg/Opus container from parsed frames (proper granule position handling)
        function createOggOpusFromFrames(frames) {
            const serialNumber = 0x12345678;
            
            // Headers
            const idHeader = createOpusIdHeader();
            const commentHeader = createOpusCommentHeader();
            
            const pages = [];
            pages.push(createOggPage(idHeader, 0, 0, 2, serialNumber)); // BOS
            pages.push(createOggPage(commentHeader, 1, 0, 0, serialNumber));
            
            // Audio pages: pack multiple packets per page (up to 255 lacing segments)
            let pageSequence = 2;
            let totalSamples = 0;
            let validFrames = 0;
            
            let currentPackets = [];
            let currentSegments = 0;
            let currentDataSize = 0;
            
            const flushPage = (isLast) => {
                if (currentPackets.length === 0) return;
                const granulePos = totalSamples; // granule at end of last packet in page
                const flags = isLast ? 4 : 0; // EOS on final page
                pages.push(createOggPageFromPackets(currentPackets, pageSequence++, granulePos, flags, serialNumber));
                currentPackets = [];
                currentSegments = 0;
                currentDataSize = 0;
            };
            
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i].data;
                if (!frame || frame.length === 0) continue;
                if (isComfortNoiseFrame(frame)) continue;
                
                const sampleCount = getSampleCountForFrame(frame);
                if (sampleCount === 0) continue; // skip invalid/unknown configs
                
                const segmentsNeeded = Math.ceil(frame.length / 255);
                
                // Flush if adding this packet would exceed lacing limits
                if (currentSegments + segmentsNeeded > 255 || currentDataSize + frame.length > 65000) {
                    flushPage(false);
                }
                
                currentPackets.push(frame);
                currentSegments += segmentsNeeded;
                currentDataSize += frame.length;
                totalSamples += sampleCount;
                validFrames++;
            }
            
            // Flush remaining packets (EOS)
            flushPage(true);
            
            console.log(`Created Ogg container: ${validFrames} valid frames, total samples: ${totalSamples}, pages: ${pages.length}`);
            
            // Combine all pages
            const totalLength = pages.reduce((sum, p) => sum + p.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const page of pages) {
                result.set(page, offset);
                offset += page.length;
            }
            
            return result.buffer;
        }

        // Build an Ogg page containing one or more packets
        function createOggPageFromPackets(packets, sequenceNumber, granulePos, flags, serialNumber) {
            // Build segment table
            let segmentCount = 0;
            for (const pkt of packets) {
                segmentCount += Math.ceil(pkt.length / 255);
            }
            const segmentTable = new Uint8Array(segmentCount);
            let segIdx = 0;
            for (const pkt of packets) {
                let remaining = pkt.length;
                while (remaining > 0) {
                    const segSize = Math.min(255, remaining);
                    segmentTable[segIdx++] = segSize;
                    remaining -= segSize;
                }
            }
            
            const headerSize = 27 + segmentTable.length;
            const packetsSize = packets.reduce((s, p) => s + p.length, 0);
            const pageSize = headerSize + packetsSize;
            
            const page = new Uint8Array(pageSize);
            const view = new DataView(page.buffer);
            
            // OggS header
            page[0] = 0x4F; page[1] = 0x67; page[2] = 0x67; page[3] = 0x53;
            page[4] = 0; // version
            page[5] = flags;
            view.setUint32(6, granulePos & 0xFFFFFFFF, true);
            view.setUint32(10, Math.floor(granulePos / 0x100000000), true);
            view.setUint32(14, serialNumber, true);
            view.setUint32(18, sequenceNumber, true);
            view.setUint32(22, 0, true); // checksum placeholder
            page[26] = segmentTable.length;
            
            // Segment table
            page.set(segmentTable, 27);
            
            // Packet data
            let dataOffset = 27 + segmentTable.length;
            for (const pkt of packets) {
                page.set(pkt, dataOffset);
                dataOffset += pkt.length;
            }
            
            // CRC over entire page
            const crc = computeOggCRC32(page);
            view.setUint32(22, crc, true);
            
            return page;
        }
        
        // Decode raw Opus packets to AudioBuffer (backward compatibility for non-raw files)
        async function decodeRawOpusToAudioBuffer(rawOpusData, audioContext) {
            const data = rawOpusData instanceof Uint8Array ? rawOpusData : new Uint8Array(rawOpusData);
            
            // Wrap raw Opus packets in Ogg container
            const oggOpusData = createOggOpusFile(data.buffer);
            const blob = new Blob([oggOpusData], { type: 'audio/ogg; codecs=opus' });
            const url = URL.createObjectURL(blob);
            
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                URL.revokeObjectURL(url);
                return audioBuffer;
            } catch (nativeError) {
                URL.revokeObjectURL(url);
                throw new Error('Failed to decode Opus: ' + nativeError.message);
            }
        }
        
        // Download functions
        async function downloadMultiTrack(recordingId) {
            if (!window.currentRecording || !window.currentRecording.audioFiles) {
                alert('No audio files available for this recording.');
                return;
            }

            const format = document.getElementById('multitrack-format-select').value;
            const audioFiles = window.currentRecording.audioFiles;
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            showProgress(0, 'Decoding and encoding multi-track files...');
            
            for (let i = 0; i < audioFiles.length; i++) {
                const file = audioFiles[i];
                showProgress((i / audioFiles.length) * 100, `Processing ${i + 1}/${audioFiles.length}...`);
                
                try {
                    const response = await fetch(file.url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const arrayBuffer = await response.arrayBuffer();
                    if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                        throw new Error('Empty audio file');
                    }
                    
                    // Check if this is a raw dump file
                    let audioBuffer;
                    if (file.filename.endsWith('.raw')) {
                        // Parse and decode raw dump file
                        audioBuffer = await decodeRawDumpToAudioBuffer(arrayBuffer, audioContext);
                    } else {
                        // Legacy: decode raw Opus (non-dump format)
                        audioBuffer = await decodeRawOpusToAudioBuffer(new Uint8Array(arrayBuffer), audioContext);
                    }
                    
                    // Encode to requested format
                    const blob = await encodeAudioBuffer(audioBuffer, format);
                    
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${file.userId}.${format}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                } catch (error) {
                    console.error(`Failed to download ${file.filename}:`, error);
                    alert(`Failed to encode ${file.filename}: ${error.message}`);
                }
            }
            
            showProgress(100, 'Complete!');
            setTimeout(() => hideProgress(), 1000);
        }

        async function downloadSingleTrack(recordingId) {
            if (!window.currentRecording || !window.currentRecording.audioFiles) {
                alert('No audio files available for this recording.');
                return;
            }

            const format = document.getElementById('format-select').value;
            const audioFiles = window.currentRecording.audioFiles;
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            showProgress(0, 'Decoding audio files...');

            try {
                // Load and decode all audio files (with timing)
                const items = [];
                for (let i = 0; i < audioFiles.length; i++) {
                    showProgress((i / audioFiles.length) * 50, `Decoding ${i + 1}/${audioFiles.length}...`);
                    
                    const response = await fetch(audioFiles[i].url);
                    const arrayBuffer = await response.arrayBuffer();
                    
                    // Check if this is a raw dump file
                    let audioBuffer;
                    let startMs = 0;
                    if (audioFiles[i].filename.endsWith('.raw')) {
                        // Parse and decode raw dump file with timing
                        const res = await decodeRawDumpWithTiming(arrayBuffer, audioContext);
                        audioBuffer = res.audioBuffer;
                        startMs = res.startMs || 0;
                    } else {
                        // Legacy: decode raw Opus (non-dump format)
                        audioBuffer = await decodeRawOpusToAudioBuffer(new Uint8Array(arrayBuffer), audioContext);
                    }
                    items.push({ buffer: audioBuffer, userId: audioFiles[i].userId, startMs });
                }

                showProgress(50, 'Mixing audio...');
                
                // Align by startMs (earliest starts at offset 0)
                const minStartMs = Math.min(...items.map(i => i.startMs || 0));
                const itemsWithOffsets = items.map(i => {
                    const offsetSamples = ((i.startMs || 0) - minStartMs) * (items[0].buffer.sampleRate / 1000);
                    return { buffer: i.buffer, offsetSamples };
                });
                
                const mixedBuffer = mixAudioBuffersWithOffsets(itemsWithOffsets);
                
                showProgress(75, `Encoding to ${format.toUpperCase()}...`);
                
                // Encode to requested format
                const blob = await encodeAudioBuffer(mixedBuffer, format);
                
                showProgress(100, 'Complete!');
                
                // Download
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${recordingId}.${format}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                setTimeout(() => hideProgress(), 2000);
            } catch (error) {
                console.error('Failed to create single track:', error);
                alert('Failed to create single track. Error: ' + error.message);
                hideProgress();
            }
        }

        // Audio processing functions - now using WASM decoder directly

        // Mix buffers with offsets (offsetSamples for each track)
        function mixAudioBuffersWithOffsets(items) {
            if (items.length === 0) return null;
            if (items.length === 1 && (!items[0].offsetSamples || items[0].offsetSamples === 0)) return items[0].buffer;

            const sampleRate = items[0].buffer.sampleRate;
            const numberOfChannels = items[0].buffer.numberOfChannels;

            // Determine total length accounting for offsets
            let maxLength = 0;
            for (const item of items) {
                const offset = Math.max(0, Math.floor(item.offsetSamples || 0));
                maxLength = Math.max(maxLength, offset + item.buffer.length);
            }

            const mixedBuffer = new AudioContext().createBuffer(numberOfChannels, maxLength, sampleRate);

            for (let channel = 0; channel < numberOfChannels; channel++) {
                const mixedData = mixedBuffer.getChannelData(channel);
                for (const item of items) {
                    const offset = Math.max(0, Math.floor(item.offsetSamples || 0));
                    const data = item.buffer.getChannelData(channel);
                    for (let i = 0; i < data.length; i++) {
                        const idx = offset + i;
                        if (idx < mixedData.length) {
                            mixedData[idx] += data[i];
                        }
                    }
                }
                // Normalize to prevent clipping
                for (let i = 0; i < mixedData.length; i++) {
                    mixedData[i] = Math.max(-1, Math.min(1, mixedData[i]));
                }
            }

            return mixedBuffer;
        }

        async function encodeAudioBuffer(audioBuffer, format) {
            if (format === 'wav') {
                return audioBufferToWav(audioBuffer);
            } else if (format === 'opus') {
                // Use MediaRecorder API for Opus encoding (browser native)
                return await encodeToOpus(audioBuffer);
            } else {
                // Fallback to WAV for unsupported formats
                alert(`Note: ${format.toUpperCase()} encoding is not supported. Downloading as WAV instead.`);
                return audioBufferToWav(audioBuffer);
            }
        }
        
        async function encodeToOpus(audioBuffer) {
            return new Promise((resolve, reject) => {
                try {
                    // Create a MediaStream from AudioBuffer
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    
                    const destination = audioContext.createMediaStreamDestination();
                    source.connect(destination);
                    
                    // Use MediaRecorder with Opus codec
                    const mediaRecorder = new MediaRecorder(destination.stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'audio/webm;codecs=opus' });
                        resolve(blob);
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        reject(new Error('MediaRecorder error: ' + event.error));
                    };
                    
                    // Start recording
                    source.start(0);
                    mediaRecorder.start();
                    
                    // Stop after buffer duration
                    setTimeout(() => {
                        source.stop();
                        mediaRecorder.stop();
                    }, (audioBuffer.length / audioBuffer.sampleRate) * 1000 + 100);
                    
                } catch (error) {
                    // Fallback to WAV if Opus encoding fails
                    console.warn('Opus encoding failed, falling back to WAV:', error);
                    resolve(audioBufferToWav(audioBuffer));
                }
            });
        }

        function audioBufferToWav(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const length = audioBuffer.length;
            const arrayBuffer = new ArrayBuffer(44 + length * numChannels * bytesPerSample);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * numChannels * bytesPerSample, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, length * numChannels * bytesPerSample, true);
            
            // Convert audio data
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function showProgress(percent, text) {
            const container = document.getElementById('progress-container');
            const fill = document.getElementById('progress-fill');
            const textEl = document.getElementById('progress-text');
            
            container.classList.add('active');
            fill.style.width = percent + '%';
            textEl.textContent = text || `${Math.round(percent)}%`;
        }

        function hideProgress() {
            const container = document.getElementById('progress-container');
            container.classList.remove('active');
        }

        async function deleteRecording(recordingId) {
            const deleteKey = document.getElementById('delete-key-input').value.trim();
            
            if (!deleteKey) {
                alert('Please enter the delete key.');
                return;
            }
            
            if (!confirm('Are you sure you want to delete this recording? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/recordings/${recordingId}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ deleteKey })
                });
                
                if (response.ok) {
                    alert('Recording deleted successfully.');
                    showRecordingsList();
                } else {
                    const error = await response.json();
                    alert('Failed to delete recording: ' + (error.error || 'Invalid delete key'));
                }
            } catch (error) {
                alert('Failed to delete recording: ' + error.message);
            }
        }

        function logout() {
            state.authToken = null;
            state.currentRecordingId = null;
            showPage('auth');
            document.getElementById('auth-token').value = '';
            window.history.pushState({}, '', '/');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Expose functions to global scope for onclick handlers
        window.downloadMultiTrack = downloadMultiTrack;
        window.downloadSingleTrack = downloadSingleTrack;
        window.deleteRecording = deleteRecording;
        window.logout = logout;
        window.showRecordingsList = showRecordingsList;

        // Handle browser back/forward
        window.addEventListener('popstate', () => {
            const pathParts = window.location.pathname.split('/');
            if (pathParts[1] === 'recording' && pathParts[2]) {
                if (state.authToken) {
                    showRecordingDetail(pathParts[2]);
                }
            } else {
                if (state.authToken) {
                    showRecordingsList();
                }
            }
        });
    </script>
    </body>
</html>
